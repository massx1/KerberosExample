package net.tirasa.kerberosexample;

import static net.tirasa.kerberosexample.Commons.KERB_V5_OID;
import static net.tirasa.kerberosexample.Commons.KRB5_PRINCIPAL_NAME_OID;
import static net.tirasa.kerberosexample.Commons.LOG;
import static net.tirasa.kerberosexample.Commons.setProperties;

import java.io.IOException;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.Set;
import javax.security.auth.Subject;
import javax.security.auth.login.LoginException;
import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSCredential;
import org.ietf.jgss.GSSException;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.GSSName;
import sun.misc.BASE64Encoder;

public class SecondGSSClient extends Commons {

    public static void main(final String args[]) throws LoginException, NoSuchAlgorithmException, KeyManagementException,
            IOException, PrivilegedActionException {
        setProperties();
        final String ticket = retrieveTicket(SERVICE_PRINCIPAL_NAME);
        LOG.debug("Calling server with ticket {}", ticket);
        postWithTicket(ticket);
    }

    public static String retrieveTicket(final String applicationPrincipal) throws LoginException,
            PrivilegedActionException, MalformedURLException {
//        final Subject subject = login();
        final Subject subject = kerberosLogin();

        LOG.debug("Authenticated with {}", subject);

        final Set<Principal> principalSet = subject.getPrincipals();
        if (principalSet.size() != 1) {
            LOG.error("No or several principals {}", principalSet);
            throw new AssertionError("No or several principals: " + principalSet);
        }
        final Principal userPrincipal = principalSet.iterator().next();
        LOG.debug("user principale found {}", userPrincipal);

        final TicketCreatorAction action = new TicketCreatorAction(userPrincipal.getName(), applicationPrincipal);
        final StringBuffer outputBuffer = new StringBuffer();
        action.setOutputBuffer(outputBuffer);

        Subject.doAs(subject, action);

        return outputBuffer.toString();
    }

    private static class TicketCreatorAction implements PrivilegedExceptionAction {

        private final String userPrincipal;

        private final String applicationPrincipal;

        private StringBuffer outputBuffer;

        public TicketCreatorAction(final String userPrincipal, final String applicationPrincipal) {
            this.userPrincipal = userPrincipal;
            this.applicationPrincipal = applicationPrincipal;
        }

        public void setOutputBuffer(final StringBuffer newOutputBuffer) {
            outputBuffer = newOutputBuffer;
        }

        @Override
        public Object run() {
            try {
                LOG.debug("Creating ticket");
                createTicket();
            } catch (final GSSException ex) {
                LOG.error("GSSException", ex);
                throw new Error(ex);
            }
            return null;
        }

        private void createTicket() throws GSSException {
            final GSSManager manager = GSSManager.getInstance();
            final GSSName clientName = manager.createName(userPrincipal, KRB5_PRINCIPAL_NAME_OID);

            LOG.debug("GSSname client name created {}", clientName);

            final GSSCredential clientCred = manager.createCredential(clientName,
                    8 * 3600,
                    KERB_V5_OID,
                    GSSCredential.INITIATE_ONLY);

            LOG.debug("GSSCredentials created {}", clientCred);

            final GSSName serverName = manager.createName(applicationPrincipal, KRB5_PRINCIPAL_NAME_OID);

            LOG.debug("GSSName server name created {}", serverName);

            final GSSContext context = manager.createContext(serverName,
                    KERB_V5_OID,
                    clientCred,
                    GSSContext.DEFAULT_LIFETIME);

            LOG.debug("GSSContext created {}", context);

            context.requestMutualAuth(true);
            context.requestConf(false);
            context.requestInteg(true);

//            final byte[] outToken = context.initSecContext(new byte[0], 0, 0);
            byte[] outToken = new byte[0];

            while (!context.isEstablished()) {

                // token is ignored on the first call
                outToken = context.initSecContext(outToken, 0, outToken.length);

                // Send a token to the server if one was generated by
                // initSecContext
                if (outToken != null) {

                    outputBuffer.append(String.format("Src Name: %s\n", context.getSrcName()));
                    outputBuffer.append(String.format("Target  : %s\n", context.getTargName()));
                    outputBuffer.append(new BASE64Encoder().encode(outToken));
                    outputBuffer.append("\n");

//                    outputBuffer.writeInt(outToken.length);
//                    outputBuffer.write(outToken);
//                    outputBuffer.flush();
                }

                // If the client is done with context establishment
                // then there will be no more tokens to read in this loop
//                if (!context.isEstablished()) {
//                    outToken = new byte[inStream.readInt()];
//                    if (true) {
//                        System.out.println("reading token = " + getHexBytes(outToken));
//                        System.out.println("Will read input token of size " + outToken.length
//                                + " for processing by initSecContext");
//                    }
//                    inStream.readFully(outToken);
//                }
            }

            LOG.debug("Token created {}", outToken);

            context.dispose();
        }
    }
}
